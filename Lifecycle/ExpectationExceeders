Team Members: Noah Horner, Taj Jivan, Austin Mahala, Josh Pearman

Task: Define CMMI.
A model to evaluate current practices lay out a path for improvements and consistency.

Activity One Results:
  Requirements: Documentation of what is required.
  Design: Brain storming to implement how to meet and exceed the customers expectations on the project.
  Implementation: Manifesting the design into code and a testable project.
  Testing: Using the product from the perspective of a user to test the product to patch and resolve bugs.
  Release: The finished product is launched to be used by the end user.
  Support/Maintenance: Finding and solving problems not initially found in testing.
  Update: Once product is released, improvements are released in the product.

Requirements:
 - Determining the required functionality of the final product by asking the customer clarifying questions.
 - Mandatory vs optional.
 - Functional and non-functional (Example: Code language).
 - Document in SRS (Software Requirements Specification).
 - Numbering Requirements.
 - Division of requirements into smaller tasks.

Design:
 - Creating flow charts for high level design.
 - Documenting how to satisfy requirements.
 - Using pseudocode/UML for low level design.
 - Requirements traceability matrix.

Implementation:
 - Self-documented code with detailed notes based on the UML, flow charts, and pseudocode.
 - Update all documents as the program creation progresses.
 - Requirement traceability matrix post condition.
 - Checking for bugs and ensuring the code runs efficiently and as expected.

Testing:
 - Testing for each SRS document.
 - Creating solutions for the test cases.
 - RTM on the test cases.
 - Documenting the test results.

Maintenance/Support:
 - Collect bug/crash reports.
 - Design and test solutions for bugs and crashes.
 - Decide priority on bugs based on requirements.
 - Fixing and improving current functionality of the release.

Update:
 - Adding new functionality and/or design changes.
